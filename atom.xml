<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wty-xjtu.github.io</id>
    <title>Gridea</title>
    <updated>2021-02-20T15:49:16.038Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wty-xjtu.github.io"/>
    <link rel="self" href="https://wty-xjtu.github.io/atom.xml"/>
    <subtitle>在学了在学了</subtitle>
    <logo>https://wty-xjtu.github.io/images/avatar.png</logo>
    <icon>https://wty-xjtu.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[OpenMV 电控实战]]></title>
        <id>https://wty-xjtu.github.io/post/openmv-dian-kong-shi-zhan/</id>
        <link href="https://wty-xjtu.github.io/post/openmv-dian-kong-shi-zhan/">
        </link>
        <updated>2021-02-20T15:29:09.000Z</updated>
        <content type="html"><![CDATA[<h2 id="openmv-电控实战">OpenMV 电控实战</h2>
<ol start="0">
<li>烧录：工具-将打开的脚本保存到OpenMV Cam，然后可以更改main函数名实现函数的封装</li>
<li>thresholds是颜色的阈值，threshold可通过tool调，lab方案也可以,<mark>千万要记得开始前先调颜色阈值！</mark></li>
</ol>
<blockquote>
<p>注意：这个参数是一个列表，可以包含多个颜色。如果你只需要一个颜色，那么在这个列表中只需要有一个颜色值，如果你想要多个颜色阈值，那这个列表就需要多个颜色阈值。注意：在返回的色块对象blob可以调用code方法，来判断是什么颜色的色块。</p>
</blockquote>
<ol start="2">
<li>多色识别的时候，会将二进制数转换为十进制数，要注意前面的定义</li>
<li>详解thershold</li>
</ol>
<ul>
<li>x_stride 就是查找的色块的x方向上最小宽度的像素，默认为2，如果你只想查找宽度10个像素以上的色块，那么就设置这个参数为10：</li>
</ul>
<pre><code>blobs = img.find_blobs([red],x_stride=10)
</code></pre>
<ul>
<li>y_stride 就是查找的色块的y方向上最小宽度的像素，默认为1，如果你只想查找宽度5个像素以上的色块，那么就设置这个参数为5：</li>
</ul>
<pre><code>blobs = img.find_blobs([red],y_stride=5)
</code></pre>
<ul>
<li>
<p>invert 反转阈值，把阈值以外的颜色作为阈值进行查找</p>
</li>
<li>
<p>area_threshold 面积阈值，如果色块被框起来的面积小于这个值，会被过滤掉</p>
</li>
<li>
<p>pixels_threshold 像素个数阈值，如果色块像素数量小于这个值，会被过滤掉</p>
</li>
<li>
<p>merge 合并，如果设置为True，那么合并所有重叠的blob为一个。<br>
注意：这会合并所有的blob，无论是什么颜色的。如果你想混淆多种颜色的blob，只需要分别调用不同颜色阈值的find_blobs。</p>
</li>
</ul>
<pre><code>all_blobs = img.find_blobs([red,blue,yellow],merge=True)

red_blobs = img.find_blobs([red],merge=True)
blue_blobs = img.find_blobs([blue],merge=True)
yellow_blobs = img.find_blobs([yellow],merge=True)
</code></pre>
<ul>
<li>margin 边界，如果设置为1，那么两个blobs如果间距1一个像素点，也会被合并。</li>
</ul>
<ol start="4">
<li>阈值</li>
</ol>
<pre><code>red = (minL, maxL, minA, maxA, minB, maxB)
#元组里面的数值分别是L A B 的最大值和最小值。
</code></pre>
<ol start="5">
<li>blobs是一个列表</li>
</ol>
<blockquote>
<p>find_blobs对象返回的是多个blob的列表。（注意区分blobs和blob，这只是一个名字，用来区分多个色块，和一个色块）。<br>
列表类似与C语言的数组，一个blobs列表里包含很多blob对象，blobs对象就是色块，每个blobs对象包含一个色块的信息。</p>
</blockquote>
<pre><code>blobs = img.find_blobs([red])
</code></pre>
<ul>
<li>blobs就是很多色块。</li>
</ul>
<p>可以用for循环把所有的色块找一遍。</p>
<pre><code>for blob in blobs:
    print(blob.cx())
</code></pre>
<ul>
<li>blob.rect() 返回这个色块的外框——矩形元组(x, y, w, h)，可以直接在image.draw_rectangle中使用。</li>
<li>blob.x() 返回色块的外框的x坐标（int），也可以通过blob[0]来获取。</li>
<li>blob.y() 返回色块的外框的y坐标（int），也可以通过blob[1]来获取。</li>
<li>blob.w() 返回色块的外框的宽度w（int），也可以通过blob[2]来获取。</li>
<li>blob.h() 返回色块的外框的高度h（int），也可以通过blob[3]来获取。</li>
<li>blob.pixels() 返回色块的像素数量（int），也可以通过blob[4]来获取。</li>
<li>blob.cx() 返回色块的外框的中心x坐标（int），也可以通过blob[5]来获取。</li>
<li>blob.cy() 返回色块的外框的中心y坐标（int），也可以通过blob[6]来获取。</li>
<li>blob.rotation() 返回色块的旋转角度（单位为弧度）（float）。如果色块类似一个铅笔，那么这个值为0<sub>180°。如果色块是一个圆，那么这个值是无用的。如果色块完全没有对称性，那么你会得到0</sub>360°，也可以通过blob[7]来获取。<br>
+blob.code() 返回一个16bit数字，每一个bit会对应每一个阈值。举个例子：</li>
</ul>
<pre><code>blobs = img.find_blobs([red, blue, yellow], merge=True)
</code></pre>
<blockquote>
<p>如果这个色块是红色，那么它的code就是0001，如果是蓝色，那么它的code就是0010。注意：一个blob可能是合并的，如果是红色和蓝色的blob，那么这个blob就是0011。这个功能可以用于查找颜色代码。也可以通过blob[8]来获取。</p>
</blockquote>
<ul>
<li>blob.count() 如果merge=True，那么就会有多个blob被合并到一个blob，这个函数返回的就是这个的数量。如果merge=False，那么返回值总是1。也可以通过blob[9]来获取。</li>
<li>blob.area() 返回色块的外框的面积。应该等于(w * h)</li>
<li>blob.density() 返回色块的密度。这等于色块的像素数除以外框的区域。如果密度较低，那么说明目标锁定的不是很好。<br>
比如，识别一个红色的圆，返回的blob.pixels()是目标圆的像素点数，blob.area()是圆的外接正方形的面积。</li>
</ul>
<ol start="6">
<li>get_regression函数<br>
image.get_regression(thresholds[, invert=False[, roi[, x_stride=2[, y_stride=1[, area_threshold=10[, pixels_threshold=10[, robust=False]]]]]]])</li>
</ol>
<blockquote>
<p>对图像所有阈值像素进行线性回归计算。这一计算通过最小二乘法进行，通常速度较快，但不能处理任何异常值。 若 robust 为True，则使用Theil-Sen线性回归算法，它计算图像中所有阈值像素的斜率的中位数。 若在阈值处理后有太多像素，即使在80x60的图像上，这个O(N^2)操作也可能将您的FPS降到5帧以下。 但是，只要阈值转换后的像素数量较少，即使在高达30％的阈值像素是异常值的情况下也依然有效，鲁棒性好。</p>
</blockquote>
<ul>
<li>thresholds 必须是元组列表。 [(lo, hi), (lo, hi), ..., (lo, hi)] 定义你想追踪的颜色范围。 对于灰度图像，每个元组需要包含两个值 - 最小灰度值和最大灰度值。 仅考虑落在这些阈值之间的像素区域。 对于RGB565图像，每个元组需要有六个值(l_lo，l_hi，a_lo，a_hi，b_lo，b_hi) - 分别是LAB L，A和B通道的最小值和最大值。 为方便使用，此功能将自动修复交换的最小值和最大值。 此外，如果元组大于六个值，则忽略其余值。相反，如果元组太短，则假定其余阈值处于最大范围。</li>
</ul>
<blockquote>
<p>获取所跟踪对象的阈值，只需在IDE帧缓冲区中选择（单击并拖动）跟踪对象。 直方图会相应地更新到所在区域。然后只需写下颜色分布在每个直方图通道中起始与下降位置。 这些将是 thresholds 的低值和高值。 由于上下四分位数据相差微小，故手动确定阈值为佳。</p>
</blockquote>
<p>您还可以通过进入OpenMV IDE中的 工具 -&gt;机器视觉 -&gt;阈值编辑器 并从GUI窗口中拖动滑块来确定颜色阈值。</p>
<ul>
<li>invert 反转阈值操作，像素在已知颜色范围之外进行匹配，而非在已知颜色范围内。invert 反转阈值操作，像素在已知颜色范围之外进行匹配，而非在已知颜色范围内。</li>
<li>roi 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。 操作范围仅限于 roi 区域内的像素。</li>
<li>x_stride 是调用函数时要跳过的x像素数。</li>
<li>y_stride 是调用函数时要跳过的y像素数。</li>
<li>roi 是感兴趣区域的矩形元组(x，y，w，h)。如果未指定，ROI即整个图像的图像矩形。 操作范围仅限于 roi 区域内的像素。</li>
<li>x_stride 是调用函数时要跳过的x像素数。</li>
<li>y_stride 是调用函数时要跳过的y像素数。</li>
</ul>
<blockquote>
<p>如果回归后的边界框区域小于 area_threshold ，则返回None。<br>
如果回归后的像素数小于 pixel_threshold ，则返回None。<br>
不支持压缩图像和bayer图像。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://wty-xjtu.github.io/post/hello-gridea/</id>
        <link href="https://wty-xjtu.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>